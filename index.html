<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>InsureQuant — K-ICS Market Map (Balanced Treemap)</title>
  <style>
    :root{--bg:#ffffff; --card:#f8f9fa; --border:#e9ecef; --text:#212529; --muted:#6c757d; --primary:#0d6efd; --primary-hover:#0b5ed7;}
    *{box-sizing:border-box} body{margin:0;background:var(--bg);color:var(--text);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Apple SD Gothic Neo,Noto Sans KR}
    header{position:sticky;top:0;padding:10px 16px;border-bottom:1px solid var(--border);background:#ffffff;z-index:1000}
    .brand{font-weight:700;margin-bottom:12px;cursor:pointer;color:var(--primary);text-decoration:none}
    .brand:hover{color:var(--primary-hover)}
    .tabs{display:flex;gap:4px;margin-bottom:0}
    .tab{padding:8px 16px;border:1px solid var(--border);border-radius:8px 8px 0 0;background:var(--card);color:var(--muted);text-decoration:none;font-size:14px;font-weight:500;transition:all 0.2s;cursor:pointer}
    .tab:hover{background:var(--primary);color:white;border-color:var(--primary)}
    .tab.active{background:var(--primary);color:white;border-color:var(--primary)}
    .container{max-width:1320px;margin:0 auto;padding:16px}
    .panel{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
    .controls{display:flex;gap:12px;align-items:center;flex-wrap:wrap;justify-content:space-between;margin-bottom:8px}
    .legend{display:flex;gap:8px;align-items:center;font-size:12px;color:var(--muted)}
    .swatch{width:110px;height:10px;background:linear-gradient(90deg,#7f1d1d,#ef4444,#fca5a5,#34d399,#16a34a,#14532d);border-radius:6px}
    .select{padding:8px 10px;border:1px solid var(--border);border-radius:8px;background:#ffffff;color:#212529}
    .toggle-switch{position:relative;display:inline-block;width:60px;height:30px}
    .toggle-input{opacity:0;width:0;height:0}
    .toggle-label{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;transition:.4s;border-radius:30px}
    .toggle-label:before{position:absolute;content:"";height:22px;width:22px;left:4px;bottom:4px;background-color:white;transition:.4s;border-radius:50%}
    .toggle-input:checked + .toggle-label{background-color:var(--primary)}
    .toggle-input:checked + .toggle-label:before{transform:translateX(30px)}
    .toggle-slider{display:none}
    #map{position:relative;height:76vh;min-height:560px;border-radius:14px;overflow:hidden;border:1px solid var(--border)}
    .group{position:absolute;border:1px solid rgba(0,0,0,.12);border-radius:10px;overflow:hidden;background:rgba(0,0,0,.02);box-sizing:border-box}
    .group-title{position:absolute;left:6px;top:6px;font-size:12px;color:var(--muted);background:rgba(255,255,255,.8);padding:2px 6px;border-radius:6px;z-index:2}
    .cell{position:absolute;border:1px solid rgba(0,0,0,.08);border-radius:8px;padding:6px;display:flex;flex-direction:column;justify-content:space-between;overflow:hidden;transition:all 0.2s;box-sizing:border-box}
    .cell:hover{transform:scale(1.02);box-shadow:0 4px 12px rgba(0,0,0,0.15);z-index:10}
    .name{font-weight:700;font-size:12px;line-height:1.2;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .ratio{font-size:15px;font-weight:700}
    .meta{font-size:11px;color:var(--muted)}
  </style>
</head>
<body>
  <header>
    <a href="index.html" class="brand">InsureQuant <span class="hint" style="color:var(--muted);font-weight:400">K-ICS Market Map (Balanced Treemap)</span></a>
    <div class="tabs">
      <a href="K-ICS.html" class="tab">K-ICS</a>
      <a href="IFRS17.html" class="tab">IFRS17</a>
      <a href="공시보고서.html" class="tab">공시/보고서</a>
    </div>
  </header>
  <div class="container">
    <div class="panel">
      <div class="controls">
        <div style="display:flex;gap:16px;align-items:center;flex-wrap:wrap">
          <div>
            <label>업권: 
              <select id="sector" class="select">
                <option value="ALL">전체</option>
                <option value="Life">생명보험</option>
                <option value="Non-Life">손해보험</option>
              </select>
            </label>
          </div>
          <div style="display:flex;align-items:center;gap:12px">
            <span style="font-size:14px;color:var(--text)">K-ICS 지급여력비율</span>
            <div class="toggle-switch">
              <input type="checkbox" id="ratioToggle" class="toggle-input">
              <label for="ratioToggle" class="toggle-label">
                <span class="toggle-slider"></span>
              </label>
            </div>
            <span style="font-size:14px;color:var(--text)">기본자본비율</span>
          </div>
        </div>
        <div class="legend">
          <div id="legendText">색상: K-ICS 비율</div>
          <div class="swatch"></div>
          <div>크기: 지급여력기준금액</div>
        </div>
      </div>
      <div id="map"></div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script>
    const jsonPath = 'kics_disclosure.json';
    let allData = [];
    let GROUPED = {};
    
    // 숫자 값 추출 함수 (쉼표 제거)
    function extractNumericValue(value) {
      if (value === null || value === undefined || value === '') return null;
      const strValue = String(value).replace(/,/g, '').trim();
      const numValue = parseFloat(strValue);
      return isNaN(numValue) ? null : numValue;
    }
    
    // 최신 분기 추출
    function getLatestQuarter(data) {
      const allQuarters = Array.from(new Set(data.map(row => row['공시분기']))).sort((a, b) => {
        const parse = s => {
          const m = s.match(/^(\d{4})\.(\d)Q$/);
          return m ? [parseInt(m[1]), parseInt(m[2])] : [0, 0];
        };
        const [ay, aq] = parse(a), [by, bq] = parse(b);
        if (ay !== by) return by - ay;
        return bq - aq;
      });
      return allQuarters.length > 0 ? allQuarters[0] : null;
    }
    
    // JSON 데이터에서 히트맵 데이터 생성
    function processJsonData(data) {
      const latestQuarter = getLatestQuarter(data);
      if (!latestQuarter) {
        console.warn('최신 분기 데이터를 찾을 수 없습니다.');
        return { "Life": [], "Non-Life": [] };
      }
      
      console.log(`최신 분기: ${latestQuarter}`);
      
      // 최신 분기 데이터만 필터링
      const latestData = data.filter(row => row['공시분기'] === latestQuarter);
      
      // 회사별로 데이터 그룹화
      const companyMap = {};
      
      latestData.forEach(row => {
        const company = row['원수사명'];
        const insuranceType = row['생손보여부'];
        const itemNumber = row['항목번호'];
        const itemName = row['항목명'];
        const value = extractNumericValue(row['값']);
        
        if (!company || !insuranceType) return;
        
        if (!companyMap[company]) {
          companyMap[company] = {
            company: company,
            sector: insuranceType === '생명보험' ? 'Life' : 'Non-Life',
            ratio: null,
            required: null,
            basicCapitalRatio: null,
            basicCapital: null // 기본자본 값 저장
          };
        }
        
        // 항목번호로 정확하게 찾기
        // 항목번호 14: 지급여력기준금액
        if (itemNumber === 14) {
          if (value !== null) {
            companyMap[company].required = value;
          }
        }
        
        // 항목번호 27: 지급여력비율
        if (itemNumber === 27) {
          if (value !== null) {
            companyMap[company].ratio = value;
          }
        }
        
        // 항목번호 28: 기본자본비율
        if (itemNumber === 28) {
          if (value !== null) {
            companyMap[company].basicCapitalRatio = value;
          }
        }
        
        // 항목번호 2: 기본자본 (기본자본비율 계산용)
        if (itemNumber === 2) {
          if (value !== null) {
            companyMap[company].basicCapital = value;
          }
        }
      });
      
      // 모든 데이터 수집 후 기본자본비율 계산
      Object.values(companyMap).forEach(company => {
        if (!company.basicCapitalRatio && company.basicCapital !== null && company.required !== null && company.required > 0) {
          company.basicCapitalRatio = (company.basicCapital / company.required) * 100;
        }
      });
      
      // Life와 Non-Life로 분류
      const grouped = { "Life": [], "Non-Life": [] };
      
      Object.values(companyMap).forEach(company => {
        // 필수 데이터가 있는 경우만 추가
        if (company.required !== null && (company.ratio !== null || company.basicCapitalRatio !== null)) {
          grouped[company.sector].push(company);
        }
      });
      
      // required 기준으로 정렬 (내림차순)
      grouped["Life"].sort((a, b) => (b.required || 0) - (a.required || 0));
      grouped["Non-Life"].sort((a, b) => (b.required || 0) - (a.required || 0));
      
      console.log('처리된 데이터:', grouped);
      return grouped;
    }
    
    // JSON 데이터 로드
    function loadData() {
      fetch(jsonPath)
        .then(response => response.json())
        .then(data => {
          allData = data;
          GROUPED = processJsonData(data);
          const sectorSel = document.getElementById("sector");
          render(sectorSel ? sectorSel.value : "ALL");
        })
        .catch(e => {
          console.error('JSON 파일을 불러오는 중 오류 발생:', e);
          // 오류 발생 시 빈 데이터로 초기화
          GROUPED = { "Life": [], "Non-Life": [] };
          const sectorSel = document.getElementById("sector");
          render(sectorSel ? sectorSel.value : "ALL");
        });
    }
    
    

    function colorForRatio(r, ratioType = 'kics'){
      const ratio = Number.isFinite(r) ? r : 0;
      
      if (ratioType === 'basicCapital') {
        // 기본자본비율: 50% 기준
        const deviation = ratio - 50;
        const absDeviation = Math.abs(deviation);
        const maxDeviation = 50; // 0% ~ 100% 범위
        
        if (deviation >= 0) {
          // 50% 이상: 초록색 그라데이션
          const intensity = Math.min(absDeviation / maxDeviation, 1);
          const hue = 120; // 초록색
          const saturation = 30 + 50 * intensity; // 30% ~ 80%
          const lightness = 25 + 15 * (1 - intensity); // 40% ~ 25% (어두운 초록)
          return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        } else {
          // 50% 미만: 빨간색 그라데이션
          const intensity = Math.min(absDeviation / maxDeviation, 1);
          const hue = 0; // 빨간색
          const saturation = 30 + 50 * intensity; // 30% ~ 80%
          const lightness = 25 + 15 * (1 - intensity); // 40% ~ 25% (어두운 빨강)
          return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
      } else {
        // K-ICS 지급여력비율: 130% 기준
        const deviation = ratio - 130;
        const absDeviation = Math.abs(deviation);
        const maxDeviation = 130; // 0% ~ 260% 범위
        
        if (deviation >= 0) {
          // 130% 이상: 초록색 그라데이션
          const intensity = Math.min(absDeviation / maxDeviation, 1);
          const hue = 120; // 초록색
          const saturation = 30 + 50 * intensity; // 30% ~ 80%
          const lightness = 25 + 15 * (1 - intensity); // 40% ~ 25% (어두운 초록)
          return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        } else {
          // 130% 미만: 빨간색 그라데이션
          const intensity = Math.min(absDeviation / maxDeviation, 1);
          const hue = 0; // 빨간색
          const saturation = 30 + 50 * intensity; // 30% ~ 80%
          const lightness = 25 + 15 * (1 - intensity); // 40% ~ 25% (어두운 빨강)
          return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
      }
    }

    // Balanced binary partition (RecSplit) treemap
    function recsplit(items, rect) {
      // items: array of {value, data} (values unscaled; we'll scale by area)
      const sum = items.reduce((a,b)=>a+b.value,0) || 1;
      function split(list, x, y, w, h) {
        if (!list.length) return [];
        if (list.length === 1) return [{x, y, w, h, item:list[0]}];
        // sort desc
        list = list.slice().sort((a,b)=>b.value-a.value);
        const target = list.reduce((a,b)=>a+b.value,0) / 2;
        let acc = 0, idx = 0;
        while (idx < list.length && acc + list[idx].value <= target) {
          acc += list[idx].value; idx++;
        }
        if (idx === 0) idx = 1;
        const left = list.slice(0, idx);
        const right = list.slice(idx);
        const total = left.reduce((a,b)=>a+b.value,0) + right.reduce((a,b)=>a+b.value,0);
        const leftRatio = left.reduce((a,b)=>a+b.value,0) / total;
        // split along longer side to promote squareness
        if (w >= h) {
          const lw = w * leftRatio;
          return split(left, x, y, lw, h).concat(split(right, x+lw, y, w-lw, h));
        } else {
          const lh = h * leftRatio;
          return split(left, x, y, w, lh).concat(split(right, x, y+lh, w, h-lh));
        }
      }
      return split(items, rect.x, rect.y, rect.w, rect.h);
    }

    function layoutGroups(allData, rect, filterSector) {
      const sectors = Object.keys(allData).filter(s => s && s!=="Unknown");
      const groups = [];
      for (const s of sectors) {
        if (filterSector !== "ALL" && s !== filterSector) continue;
        const rows = allData[s];
        const sum = rows.reduce((a,b)=>a+b.required,0);
        if (sum>0) groups.push({ key:s, sum, rows });
      }
      const grand = groups.reduce((a,b)=>a+b.sum,0) || 1;
      const gItems = groups
        .map(g => ({ value: g.sum/grand, data: g }))
        .sort((a,b)=>b.value-a.value);

      const gRects = recsplit(gItems, rect);
      const out = [];

      for (const gr of gRects) {
        const gData = gr.item.data;
        
        // 그룹이 전체 컨테이너 경계를 넘지 않도록 제한
        const groupX = Math.max(0, Math.min(gr.x, rect.w));
        const groupY = Math.max(0, Math.min(gr.y, rect.h));
        const groupW = Math.max(0, Math.min(gr.w, rect.w - groupX));
        const groupH = Math.max(0, Math.min(gr.h, rect.h - groupY));
        
        out.push({ type:"group", sector: gData.key, x: groupX, y: groupY, w: groupW, h: groupH });

        // Inner recsplit for companies
        const padOuter = 6, titleH = 22, padInner = 6;
        
        const gx = groupX + padOuter;
        const gy = groupY + padOuter + titleH;
        const gw = Math.max(0, groupW - padOuter*2);
        const gh = Math.max(0, groupH - padOuter*2 - titleH);

        const items = gData.rows.map(d => ({ value: d.required, data: d }));

        const innerW = Math.max(0, gw - 2 * padInner);
        const innerH = Math.max(0, gh - 2 * padInner);
        const cells = recsplit(items, {x:gx+padInner, y:gy+padInner, w:innerW, h:innerH});

        const MIN_W = 64, MIN_H = 48;
        const groupRight = Math.min(gx + gw, rect.w);
        const groupBottom = Math.min(gy + gh, rect.h);
        
        for (const c of cells) {
          // 셀 좌표를 그룹 내부로 제한
          let cellX = Math.max(gx, c.x);
          let cellY = Math.max(gy, c.y);
          
          // 셀 크기 계산 (최소값 보장하되 그룹 경계를 넘지 않도록)
          let w = Math.max(MIN_W, c.w - 2);
          let h = Math.max(MIN_H, c.h - 2);
          
          // 그룹 영역을 벗어나지 않도록 엄격하게 제한
          const cellRight = cellX + w;
          const cellBottom = cellY + h;
          
          if (cellRight > groupRight) {
            w = Math.max(MIN_W, groupRight - cellX);
          }
          if (cellBottom > groupBottom) {
            h = Math.max(MIN_H, groupBottom - cellY);
          }
          
          // 최종 경계 체크: 셀이 그룹 내부에 완전히 포함되는지 확인
          if (cellX >= gx && cellY >= gy && 
              cellX + w <= groupRight && cellY + h <= groupBottom &&
              w >= MIN_W && h >= MIN_H) {
            out.push({
              type:"cell",
              x: cellX, y: cellY, w: w, h: h,
              data: c.item.data
            });
          }
        }
      }
      return out;
    }

    function render(sector) {
      const el = document.getElementById("map");
      const W = el.clientWidth, H = el.clientHeight;
      el.innerHTML = "";
      const rects = layoutGroups(GROUPED, {x:0,y:0,w:W,h:H}, sector);

      // 현재 토글 스위치 상태 확인
      const ratioType = document.getElementById('ratioToggle').checked ? 'basicCapital' : 'kics';
      
      // 범례 텍스트 업데이트
      const legendText = document.getElementById("legendText");
      legendText.textContent = ratioType === 'basicCapital' ? '색상: 기본자본비율' : '색상: K-ICS 비율';

      for (const r of rects) {
        if (r.type === "group") {
          // 그룹이 컨테이너 영역을 넘지 않도록 제한
          const groupX = Math.max(0, r.x);
          const groupY = Math.max(0, r.y);
          const groupW = Math.min(r.w, W - groupX);
          const groupH = Math.min(r.h, H - groupY);
          
          // 좌표를 정수로 반올림
          const finalGroupX = Math.floor(groupX);
          const finalGroupY = Math.floor(groupY);
          const finalGroupW = Math.floor(groupW);
          const finalGroupH = Math.floor(groupH);
          
          // 최종 경계 체크
          if (finalGroupX + finalGroupW > W || finalGroupY + finalGroupH > H) continue;
          
          const g = document.createElement("div");
          g.className = "group";
          g.style.left = finalGroupX + "px";
          g.style.top = finalGroupY + "px";
          g.style.width = finalGroupW + "px";
          g.style.height = finalGroupH + "px";
          const title = document.createElement("div");
          title.className = "group-title";
          title.textContent = r.sector === "Life" ? "생명보험" : "손해보험";
          g.appendChild(title);
          el.appendChild(g);
        } else if (r.type === "cell") {
          const d = r.data;
          
          // 셀이 컨테이너 영역을 넘지 않도록 엄격하게 제한
          const cellX = Math.max(0, Math.min(r.x, W - 64)); // 최소 너비 64 보장
          const cellY = Math.max(0, Math.min(r.y, H - 48)); // 최소 높이 48 보장
          const cellRight = Math.min(r.x + r.w, W);
          const cellBottom = Math.min(r.y + r.h, H);
          const cellW = Math.max(0, cellRight - cellX);
          const cellH = Math.max(0, cellBottom - cellY);
          
          // 최소 크기 보장 및 경계 체크
          if (cellW < 64 || cellH < 48) return; // 너무 작으면 렌더링하지 않음
          if (cellX + cellW > W || cellY + cellH > H) return; // 경계를 넘으면 렌더링하지 않음
          if (cellX < 0 || cellY < 0) return; // 음수 좌표는 렌더링하지 않음
          
          // 좌표를 정수로 반올림하여 정확도 향상
          const finalX = Math.floor(cellX);
          const finalY = Math.floor(cellY);
          const finalW = Math.floor(cellW);
          const finalH = Math.floor(cellH);
          
          // 최종 경계 체크
          if (finalX + finalW > W || finalY + finalH > H) return;
          
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.style.left = finalX + "px";
          cell.style.top = finalY + "px";
          cell.style.width = finalW + "px";
          cell.style.height = finalH + "px";
          
          // 선택된 비율 타입에 따라 색상 계산
          let displayRatio, displayValue;
          if (ratioType === 'basicCapital') {
            // 항목번호 28번의 기본자본비율만 사용
            displayValue = d.basicCapitalRatio || 0;
            displayRatio = displayValue;
            console.log(`${d.company} 기본자본비율 (항목번호 28): ${displayValue.toFixed(2)}%`);
            cell.style.background = colorForRatio(displayValue, 'basicCapital');
            cell.title = `${d.company} — 기본자본비율 ${displayValue.toFixed(1)}%, 기준금액 ${Math.round(d.required).toLocaleString()}`;
          } else {
            displayValue = d.ratio;
            displayRatio = d.ratio;
            cell.style.background = colorForRatio(d.ratio, 'kics');
            cell.title = `${d.company} — K-ICS 비율 ${(d.ratio??0).toFixed(1)}%, 기준금액 ${Math.round(d.required).toLocaleString()}`;
          }

          const name = document.createElement("div");
          name.className = "name";
          name.textContent = d.company;

          const ratio = document.createElement("div");
          ratio.className = "ratio";
          ratio.textContent = (Number.isFinite(displayRatio)? displayRatio.toFixed(1):"-") + "%";

          const meta = document.createElement("div");
          meta.className = "meta";
          meta.textContent = "기준 " + Math.round(d.required).toLocaleString();

          cell.appendChild(name);
          cell.appendChild(ratio);
          cell.appendChild(meta);
          
          // 셀 클릭 이벤트: K-ICS.html로 이동 (회사명 파라미터 전달)
          cell.style.cursor = 'pointer';
          
          // 클릭 이벤트 핸들러 (셀과 자식 요소 모두에 적용)
          const handleCellClick = function(e) {
            e.preventDefault();
            e.stopPropagation();
            const companyParam = encodeURIComponent(d.company);
            window.location.href = `K-ICS.html?company=${companyParam}&period=quarter`;
          };
          
          cell.addEventListener('click', handleCellClick);
          
          // 자식 요소들도 클릭 가능하도록 설정
          name.style.pointerEvents = 'none';
          ratio.style.pointerEvents = 'none';
          meta.style.pointerEvents = 'none';
          
          el.appendChild(cell);
        }
      }
    }

    const sel = document.getElementById("sector");
    function redraw() { render(sel.value); }
    window.addEventListener("resize", redraw);
    sel.addEventListener("change", redraw);
    
    // 토글 스위치 변경 이벤트 추가
    document.getElementById('ratioToggle').addEventListener("change", redraw);
    
    // 페이지 로드 시 CSV 데이터 자동 로드
    loadData();
  </script>
</body>
</html>
